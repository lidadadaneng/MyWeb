---
title: 01.宏观视角下的浏览器
date: 2023-03-09 16:42:42
categories:
- 前端
- 浏览器原理
tags:
- 浏览器原理
typora-root-url: ..\..
---

# 1、 浏览器简介

1995年美国的网景公司因"网景浏览器"的发布而快速崛起,之后网景还试图开发一个依靠浏览器的网络操作系统。这引起了微软的关注和警惕，1995年12月7日(12月7日是日本偷袭珍珠港的日子)，微软正式进军浏览器市场，同年微软发布windows95，并捆绑了IE，大获成功。IE出来，网景就离死不远了，网景被垄断了操作系统的微软用非技术、非正常竞争的手段打败，97年就倒闭了。到2002年，微软拿下了浏览器市场80%的份额。



直到2008年，chrome横空出世，才打破这种垄断的局面。Chrome浏览器完全颠覆了之前浏览器的架构设计，市场份额占比激增。2019年,chrome占据全球63%的市场份额。



浏览器自诞生之日起，其地位就一直很重要,而且这种重要还在不断加强。

  

随着云计算的普及和HTML5技术的快速发展，越来越多的应用从C/S架构转化B/S架构。这种改变让浏览器的重要性与日俱增。视频、音频、游戏几大核心场景也都在往Web的使用场景切换。



  



为什么需要学习浏览器的工作原理

 1、准确的评估Web项目的可行性。 

随着Web特性的极大丰富和浏览器性能的提升，越来越多的项目可以用web来开发。了解浏览器是如何工作的，能够让我们更准确地决策是否可以采用Web来开发项目。

 2、从更高的维度审视页面 

作为一名合格的开发者，你需要站在用户体验的角度来考虑页面性能。我们看以下几个常见的用户体验指标。

●用户请求一个网站时，如若1s内看不到关键内容，用户就会莫名的烦躁。

●用户点击按钮时,如果100ms内无法响应，用户就会感觉到延迟。

●如何Web中的动画没有达到60fps(每秒只能提供60帧),用户会觉得动画卡顿。

fps: 指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数

这里的页面加载时长、用户交互反馈时长、Web动画中的帧数都决定了用户体验的流畅度，并最终决定了用户体验的下过。所以我们必须解决这些问题，以免给产品造成不可挽回的伤害。



但通常，这些指标都是由一系列的复杂因素造成的。如果你要开发流畅的页面，或者诊断Web页面的性能问题，那你就需要了解URL是怎么变成页面的。这样你才可以站在全局的角度去定位问题或者写出高效的代码。



你当然可以将浏览器看成一个黑盒，左边输入url地址，经过黑盒处理之后，右边返回你预期的效果。如果你对黑盒一无所知，你倒依然可以写前端代码，也可以使用很多最佳实践的策略来优化代码，这就如同不了解操作系统的原理依然可以在操作系统上写应用。



但如果你理解这个黑盒如何工作，情况就不一样了。你可以站在更高的维度去审视你的项目，通过全局视野快速的去定位项目中的问题。比如首屏的显示就涉及了DNS、HTTP、DOM解析、CSS阻塞、JavaScript阻塞等技术因素，其中一项没有处理好就可能导致整个页面的延时。



如果你了解浏览器的工作原理，就可以把这些知识点串成一条线，连成网，最终形成自己的世界观。去以全局的角度去思考问题，解决问题。

 3、在快速迭代的技术中把握本质 

从2011年至今，前端技术呈现了大爆发式的增长，各种技术层出不穷。Node.js是前端发展的一个核心推动力，Node是基于Chrome的V8引擎来实现的，它特点就是可以脱离浏览器来执行JavaScript，实现服务器端开发。

尽管Node诞生的时间不长，但其周边已经形成了一个庞大的生态系统。与此同时，新的标准，技术如雨后春笋般出现，前端生态空气繁荣。

为什么Node能如此快速发展?根本原因还是生态位决定，浏览器功能及整个前端开发环境不足支撑日益增长的需求，所以"变化"甚至一部分激进的工程师说"革命"是这段时期的主旋律。这种变化也在不断的扩大前端工程师的知识半径。

虽然技术在迭代，但这里也蕴含这巨大的机遇，谁能快速抓住变化，谁就能收获这波变化带来的红利。



随着脚本执行效率的提高、页面渲染性能的提升和开发工具链的完善，接下来的前端会进入一个相对平稳的阶段。通俗地理解就是:等到核心技术足以支撑核心需求，那么前端生态会进入一个相对稳定的状态。



如果了解浏览器的工作机制，那么你可以梳理出来前端技术发展的脉络、更加深刻地理解当前的技术，同时你也会清楚其不足之处，以及演化的方向。



总结:学习本教程的目的就是希望通过这个教程的学习，能系统的掌握浏览器工作原理，把理论应用到实战中去。

# 2、进程和线程起步

[进程和线程](https://zhuanlan.zhihu.com/p/63310261)

浏览器是多进程的，一个页面挂掉了，并不影响第二个页面。

 一、进程和线程 

进程 : 进程是操作系统资源分配的基本单位，进程中包含线程。

```
进程：计算机上正在运行的一个应用程序就是一个进程
// 如微信正在运行,就是一个进程。
正在运行的，也就是说进程是一个动态概念，必须是正在运行的某个应用程序才能称得上是进程。
```

> 简而言之,就是正在进行中的应用程序。

![jincheng.jpg](/image/浏览器渲染/1578050417093-5f8d520c-7c5d-4237-9b8b-e4b6cab11a50.jpeg)



线程：线程是由进程所管理的。为了提升浏览器的稳定性和安全性，浏览器采取了多进程模型。

●1、线程是进程的基本单位，一个进程由一个或者多个线程组成，搞清楚这个关系之后，我们可以明确线程就是程序执行的最小单元。

●2、线程和进程一样，也是动态概念，有创建有销毁，存在只是暂时的，不是永久性的。

●3、进程与线程的区别在于进程在运行时拥有独立的内存空间，也就是说每个进程所占用的内存都是独立的

例如:微信运行时,系统会给它一个运行内存。

●4、多个线程是共享内存空间的，但是每个线程的执行是相互独立的，线程必须依赖于进程才能执行，单独的线程是无法执行的，由进程来控制多个线程的执行，没有进程就不存在线程。

例如:我先开启一个发送消息的线程,那么同时还能由一个接收消息的线程。两个线程之间完全独立

![线程.jpg](/image/浏览器渲染/1578050685065-b30256be-b57c-47de-9c13-fb58e92c132e.jpeg)



那么什么是多线程呢？一个进程中同时有多个线程在执行就是多线程，有一个很简单的方法来判断程序是单线程还是多线程：把程序的整个运行流程画出来，如果是一条回路则是单线程，如果是两条或两条以上的回路则是多线程。





总结

```
进程：就是在内存中正在运行的程序就叫一个进程，它是操作系统执行的基本单位。
   例如：正在你手机里面运行的微信就是一个进程
   特点：在内存独占一份空间

线程：是进程内的一个独立执行的单位，是CPU调度的最小单位。
```

总结:进程就是一个工厂，线程是工人。

 二、浏览器中的5个进程 

目前最新的Chrome进程架构图

![1625035099028.png](/image/浏览器渲染/1625035146515-8464d317-2372-420d-81cc-1b42cfcd6695.png)

![uTools_1678762226291](/image/浏览器渲染/uTools_1678426934237.png)

浏览器设置的时候是一个多进程模型，这样能确保浏览的安全性和稳定性。如何一个页面有问题，不影响其他页面的运行。

●**浏览器进程。** 主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。

●**渲染进程。** 核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都运行在该进程中，默认情况下，Chrome为每一个Tab标签页创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下的。

●**GPU进程。** GPU图形处理器（英语：graphics processing unit，缩写：GPU）,负责3D css效果，网页，Chrome ui的绘制。

●**网络进程。** 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立处理，成为单独一个进程。

●**插件进程。** 主要负责插件的运行，因为插件易崩溃，所以通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

![02.png](/image/浏览器渲染/1625038061963-524ae28b-5a92-4a98-80a7-8c2c5391ba09.png)

所以我们开启一个页面，至少会启动4个进程。

# **3、TCP协议:如何保证页面文件能被完整送达浏览器**

```
1、先查找缓存，检测缓存是否过期，直接返回缓存中内容
2、看域名是否被解析，DNS协议，DNS协议是基于UPD协议  ip+端口号 
3、ip地址寻址，排队等候，最多发送6个http请求
4、tcp创建链接，用户传输(三次握手)
5、利用tcp传输数据(拆分数据包，有序)  可靠，有序，服务器会按照顺序来接受
6、http请求(请求行，请求头，请求体)
7、默认不会断开keep-alive，为下次传输数据是，可以复用上次的创建的连接
8、服务器接受数据后(响应行 响应头 响应头)
```

在衡量Web页面性能的时候有一个重要的指标叫 "FP（First Paint）"，是指从**页面加载到首次开始绘制的时长**。即首屏加载速度，倘若这个过程过长极度影响用户体验。那么什么影响FP？其中有个重要因素，网络加载速度。

所以要优化Web页面的加载速度需对网络有充分的了解。那么这里我们重点讨论位于传输层的TCP，和网络层的IP协议如何工作的。

在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大的概率丢失或出错，**如何保证页面文件能被完整地送达浏览器呢？**



**一个数据包的"旅程"，谈起**

下面我们分别从 "数据包如何送达主机"，"主机如何将数据包转交给应用"，"数据包如何被完整地送到应用"这个三个角度谈论数据的传输过程。



### 一、IP：把数据包发送到目的主机

那么ip协议就是解决了从A主机把数据包发送到B主机的问题，每一台机制都只有一个唯一的地址，知道这个地址，我们就可以像寄快递一样，将数据送达给另一台主机。

计算机的地址，就是IP地址，访问任何网站就是你从一台计算机向另一台计算机请求信息。

```
http://47.108.197.28:4000/api/article
```

- 如果想把一个数据包主机A发送给主机B，那么在传输之前，数据包上会被附加上主机B的IP信息这一才能正确的寻址。
- 额外，数据包还会附加上主机A本身的IP地址，有了这些信息B才能回传信息给主机A。
- 这些信息会被封装进一个叫IP头的数据结构里。ip头是IP数据包开头的信息，包含IP版本，源IP，目的IP。

为了方便理解，先将网络分为三层结构

![image-20230314133720411](/image/浏览器渲染/image-20230314133720411.png)

那么有通过上面这张图可以看到一个数据包，从主机A到主机B的旅程：

```
1、上层会将"API"的数据包交给网络层
2、网络层就将IP头附加到数据包上，组成新的IP数据包，交给底层。
3、底层通过物理网络将数据包传输给主机B
4、数据包被传输到主机B的网络层，在这里主机B拆开数据包的IP头信息，并将拆开来的数据部分交给上层
5、最终，含有"API"的信心的数据包就到达了主机B的上层了。
```

### [二、UDP协议](https://www.yuque.com/rahm5e/rules/xv71hi) : 保证将数据送达给应用

IP是非常底层的协议，只负责发送数据包给对方电脑，但对象电脑并不知道把数据包给那个应用程序，是交给Google浏览器还是给王者荣耀。因此，需要基于IP之上能和应用打交道的协议，常用两种协议的UDP(用户数据包协议)和TCP（传输控制协议）协议。

UDP中最重要的一个信息就是端口号，端口号就是一个数字，每一个想要访问网络的程序都需要绑定一个端口号。通过UDP就能把指定的数据包发送给指定的程序了。**所以IP是通过IP地址将数据包发送给指定的电脑，而UDP是通过端口把数据包分发给了正确的应用。**

和IP头一样，端口号会被封装进UDP头里面，UDP头和原始数据包合并组成新的UPD数据包，udp头中除了目的端口，还有源端口号等信心。

![02.png](/image/浏览器渲染/1625804787280-3c243011-9644-414e-8537-b129528e7f4a.png)

下面我们一起来看下一个数据包从主机 A 旅行到主机 B 的路线：

```
1、上层将数据包交给传输层
2、传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层
3、网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层
4、数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层
5、在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用
程序；
6、最终，含有“API”信息的数据包就旅行到了主机 B 上层应用程序这里。
```

在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。

**UDP协议只管发送，不管数据是否正确可靠的送达。**

虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

### 三、 TCP：把数据完整地送达应用程序

对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用 UDP 来传输会存在两个问题：

- 数据包在传输过程中**容易丢失**；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件，**不能保证大文件数据的完整性。**

基于这两个问题，我们引入 TCP 了**。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。**相对于 UDP，TCP 有下面两个特点:

- 对于数据包丢失的情况，TCP 提供**重传机制**；
- TCP 引入了**数据包排序机制**，用来保证把乱**序的数据包组合成一个完整的文件**。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。下面看看 TCP 下的单个数据包的传输流程：

![03.png](/image/浏览器渲染/1625813251422-254e7050-66dc-48df-9096-4ee08c4deb21.png)

通过上图可以看到TCP单个数据包的传输流程和UDP的流程差不多，不同的地方在于，通过TCP头的信息保证了一块大的数据传输的完整性。

我们可以通过下图看TCP如何保证**重传机制**和数据包的**排序功能**。一个完整的TCP连接的生命周期包括了"建立连接"，"传输数据"，"断开连接"三个阶段。

![04.png](/image/浏览器渲染/1625813504787-991dc51a-acec-453e-8cd2-27a7e2c04683.png)

在传输数据阶段，**接收端需要对每个数据包进行确认**，**给发送端以反馈**。倘若在规定时间内，发送端没有接收到接收端反馈的信息，则判断为数据丢失。触发重传机制。

同样一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照TCP头部中的序号对其排序，从而保证数据的完整性。

TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度。

### 总结

- 互联网中的数据是通过数据包来传输的，数据包在传入过程中容易丢失和出错。
- IP负责吧数据包传递到目的主机
- UDP负责吧数据包送达具体应用
- 而TCP保证了数据完整地传输

其实了解TCP协议，是为了全方位的了解HTTP协议。



# **4、HTTP请求流程**

## HTTP的发展历程

1、http0.9负责传输html,最早美欧请求头和响应头

2、http1.0提供了http的header，根据header的不同来处理不同的资源。

3、每次http请求之后都会断开连接，http1.1默认开启了keep-alive,实现了链接复用。同时实现了管线化，一个域名下可以建立6个链接。

4、http1.1服务器响应的时候还是按顺序响应，这样会造成对头阻塞。

5、http2.0用同一个tcp链接来发送数据 一个域名一个tcp（多路复用），请求头压缩，服务器可以推送数据给客户端。



TCP协议是如何保证数据完整传输的，它包含建立连接，传输数据和断开连接三个阶段。

而HTTP协议，是在TCP的基础上建立的。**HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础。**通常由浏览器发起请求，用来获取不同类型的文件，例如HTML，CSS，JavaScript、图片、视频等。此外，HTTP也是浏览器使用最广的协议。规定了客户端请求，和服务器端响应数据格式的协议。



思考以下问题:

```
1、为什么通常在第一访问一个站点是，打开速度很慢，而再次访问就快了?
2、当登录一个网站后，下次再访问时，就已经处于登录状态了，如何做到的?   
```

## 浏览器端发送HTTP请求的流程

倘若你在浏览器中输入 http://47.108.197.28:4000/api/article，那么浏览器会完成那些动作?

### 1、构造请求

首先，浏览器构造请求行，信息如下  构建好之后，浏览器准备发起网络请求

```
GET /api/article HTTP/1.1
```

### 2、查找缓存

在正在发起网络请求之前，浏览器会现在浏览器缓存中查询是否有请求的文件，其实**浏览器缓存是一种本地保存的资源副本，以供下次请求时直接使用的技术。**

当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求。而不会再去源服务器中重新下载。这样做的好处:

- 缓解服务的压力，提升性能

如果缓存查找失败，则进入网络请求。

> 有缓存则取缓存，没有缓存则发送网络请求

### 3、准备IP地址和端口

HTTP和TCP的关系，因为浏览器使用HTTP协议作为应用层协议**，用来封装请求的文本信息**；并使用TCP/IP作传输层协议将它发到网络上，所以在HTTP工作开始之前，浏览器需要TCP与服务器建立连接。也就是说HTTP的内容是通过TCP的传输数据阶段来实现的。

![05.png](/image/浏览器渲染/1625816046240-1feb5199-e3dd-486c-a95b-1e655152790a.png)

数据包是通过IP地址传输给接收方的。由于IP地址是数字标识的，难以记忆，使用一个域名例如 www.baidu.com 就容易记忆了，所以基于这个需求又出现了一个服务，负责把域名和IP地址做--映射关系。这套域名映射为IP的系统叫做"域名系统"，简称DNS。

第一步浏览器会请求 DNS 返回域名对应的 IP。**当然浏览器还提供了 DNS 数据缓存服务**，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

### 4、等待TCP队列

IP地址和端口已经准备好了，是不是可以马上建立TCP连接。

不行，因为Chrome有个机制，同一个域名同时最多只能建立6个TCP连接。如果请求书少于6个，直接进入下一步，建立TCP连接。

### 5、建立TCP连接

排队等待结束后，建立TCP连接

### 6、发送HTTP请求

![01.webp](/image/浏览器渲染/1625816820533-85adb249-5895-463d-9d63-4aef57b311fb.webp)

## 服务端处理HTTP请求流程

历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。

### 1、返回请求

```
curl -i https://www.baidu.com
```

> Tips: -i 是为了返回响应行、响应头和响应体的数据。

![02.webp](/image/浏览器渲染/1625817180374-3715f392-81a4-44fa-9775-f84b2e23bd63.webp)

### 2、断开连接

通常情况下，一旦服务器向可短返回了请求数据，它就要关闭TCP连接。不过如果在浏览器或服务器在其头部信息加入

```
Connection:Keep-Alive
```

那么TCP连接在发送后将仍然保持打开状态，这样浏览器可以继续通过同一个TCP连接发送请求。

保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如一个Web页面中内嵌图片来自于同一个web站点，如果初始化长连接，就不需要重复建立新的TCP连接。

## 为什么很多站点第二次打开会很快

因为第一次加载页面的过程中，缓存了一些耗时的数据。

那么，那些数据会被缓存呢?**DNS缓存**和**页面资源缓存**这两块数据是会被浏览器缓存的。

![01.webp](/image/浏览器渲染/1625818482719-5c58bc6b-ed92-489c-ab95-ef1f7cfeed96.webp)

通过上图第一次请求可以看出，当服务器返回HTTP响应头给浏览器时，浏览器通过响应头的Cache-Control字段来设置是否缓存该资源。

```
Cache-Control:Max-age=2000 //缓存过期时间是2000
```

这也就意味着，在该缓存资源还没有过期的情况下，如果再次发送请求该资源，会之间返回缓存中的资源给浏览器。

但如果缓存过期了，浏览器则会继续发送网络请求，并且在HTTP请求头中带上:

```
If-None-Match:"4f80f-13c-3a1xb12a"
```

简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。



# **5、输入url地址到浏览器显示页面发生了什么**

从浏览器里，输入URL地址，到页面显示，这中间发生了什么?这是一道经典面试题，能比较全面的考察应聘者知识的掌握程序，其中**涉及网络、操作系统、Web等一系列的知识。**

那么我们从进程角度讨论一下

![02.webp](/image/浏览器渲染/1625992434357-e94c6c30-f995-4ef6-b208-7c805e66522f.webp)

从上图可以看到，整个过程需要各个进程之间的配合，所以在正式解释整个流程之前，我们首先回顾一下浏览器进程、渲染进程、和网络进程的主要职责。

- 浏览器进程主要负责**用户交互**、**子进程管理**和**文件存储**等功能。
- 网络进程是面向渲染进程和浏览器进程等提供**网络下载**功能。
- 渲染进程的主要职责就是把从网络上下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和用户交互的页面。 因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所有运行在渲染进程里的代码是不被信任的。这也是为什么Chrome会让渲染进程运行在安全沙箱中，就是为了保证系统的安全。

回顾了浏览器的进程架构之后，我们再结合上图我们从进程的角度，描述一下

1、浏览器进程接收到用户输入的URL请求，浏览器进程便将URL转发给网络进程

2、网络进程中发起真正的URL请求

3、网络进程接收到响应头数据，便解析响应头数据，并将数据转发给浏览器进程。

4、浏览器进程接收到网络进程的响应头数据之后，发送"提交文档"消息到渲染进程；

5、渲染进程接收到"提交文档"的消息之后，便开始准备接收HTML数据，接收数据的方式是直接和网络进程建立**数据管道。**

6、等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；

7、浏览器进程接收到渲染进程"确认提交"的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。

所谓提交文档，就是浏览器主进程，**将网络进程接收到的HTML数据提交给渲染进程**。
