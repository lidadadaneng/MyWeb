---
title: 09.浏览器安全
date: 2023-03-10 16:42:50
categories:
- 前端
- 浏览器原理
tags:
- 浏览器原理
typora-root-url: ..\..
---

# **浏览器安全**

浏览器安全可以分为三个大块

- Web页面安全
- 浏览器网络安全
- 浏览器系统安全

# **1、同源策略**

我们再分析页面的安全策略之前，先假设一下，如果页面中没有安全策略的话，Web世界是怎么样的。

Web世界是开放的，任何资源都可以接入其中，我们的网站可以加载并执行别的网站的脚本，图片，音视频等。

Web世界是开放的，这很符合Web的理念。但如果Web世界绝对自由的，那么页面行为将没有任何限制，这会造成无序或混沌的局面。出现很多不可控的问题。

比如你打开一个银行站点，然后又不小心打开一个恶意站点，如果**没有安全措施，**恶意站点就可以做很多事情:

- 修改站点的DOM，CSSOM
- 在银行站点内嵌JavaScript脚本
- 劫持用户登录的用户名和密码
- 读取银行站点的Cookie，IndexDB等数据；
- 甚至还可以将这些信息上传到自己的服务器，这样就可以在用户不知情的情况下伪造一些转账的请求信息

所以，**在没有安全保障的Web世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。**

这就引出了页面中最基础，最核心的安全策略：同源策略(Same-origin-policy)。

### 一、什么是同源策略

要了解什么是同源策略，得看看什么是同源。

**如果两个url的协议，子域名，主域名，端口号都相同，我们就称这两个URL同源。**比如下面这两个URL，它们具有相同的协议HTTPS,相同的子域名(www)和主域名baidu,以及相同的端口号443，所以我们就说这两个URL是同源的。

```
https://www.baidu.com/?category=1
https://www.baidu.com/?category=0
```

浏览器默认两个相同的源之间是可以相互访问资源和操作DOM的。不同的源之间是不能相互访问资源操作DOM的。

#### 1、例子

```js
//sever.js
const koa = require("koa");
const router = require("koa-router")();
const app = new koa();
router.get("/",async ctx=>{
    ctx.body = {
        name:"浏览器安全",
        age:10
    }
})
app.use(router.routes());
app.listen(8080)
```

```html
//index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>
</head>
<body>
    <script>
        $.ajax({
            url:"http://localhost:8080",
            success:res=>{
                console.log(res)
            }
        })
    </script>
</body>
</html>
```

控制台中提示

![01.png](/image/浏览器渲染/1627202163435-630e7019-7b54-49d2-b715-98b8a38f8308.png)

### 二、 具体来说同源策略主要表现在DOM，Web数据和网络这三个层面。

#### 1、DOM层面

同源策略限制了来自不同源的JavaScript脚本对当前DOM对象读和写的操作。

只有同一个域的才能读写，不同域之间是不能读写的。

#### 2、数据层面

同源策略限制了不同源的站点读取当前站点的Cookie,IndexDB,LocalStorage等数据。

```
http://todolist.cn/
```

在百度查看todoList中，localStorage的数据，是看不到的。

#### 3、网络层面

同源策略限制了通过XMLHttpRequest(ajax核心对象)将站点的数据，发送不同源的站点。



### 三、安全性和便利性的权衡

同源策略会**隔离**不同源的DOM操作，页面数据，网络通信，进而实现Web页面的安全。

> 例如:此时武汉疫情期间，直接封城。不要进行人流和物流的交流。

不过安全性和便利性是相互**对立**的，让不同的源之间绝对隔离，无疑是最安全的措施。但是这会使得Web项目难以开发和使用，因为我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的就是XSS攻击和CSRF攻击。这两个攻击，后续再讨论，现在聊一下**浏览器出让了同源策略的那些安全性。**

#### 1、页面中可以嵌入第三资源

同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所以HTML文件，JavaScript文件，CSS文件，图片等资源都部署到同一台服务器上，这无疑违背了Web的初衷，也带来了诸多的不便。比如将不同的资源部署到不用的CDN上时，CDN上的资源就部署在另一个域名上了，因为我们需要在同源策略上开一个口子，**当引入外部资源文件的时候，不受同源策略的约束。**

最初，浏览器是支持外部资源文件的引入的，不过这带来了很多问题，例如，浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最长是，通过各种方法往页面中注入恶意脚本。

比如，恶意程序在HTML文件内容中插入如下脚本

![01.webp](/image/浏览器渲染/1627204183357-0c9c607a-55c8-44b2-a001-e6a4a2d6cc96.webp)

当这段HTML文件的数据被发送到浏览器时，浏览器无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果，改变一些内容的连接指向。

更严重的是，它还能将页面的敏感数据，如Cookie，IndexDB,LocalStorage等数据通过XSS的手段发送给服务器。具体来讲，就是当你不小心点击了某个恶意链接，恶意的JS代码可以读取页面的数据，并将其发送给服务器。

为了解决[XSS](https://baike.baidu.com/item/XSS攻击/954065?fr=aladdin)攻击，浏览器引入了**内容安全策略**CSP。**CSP的核心思路就是让服务器来决定浏览器能够加载那些资源，让服务器决定浏览器是否能够执行内联JavaScript代码。**通过这些手段就可以大大减少XSS攻击。

#### 2、跨域资源共享

为了解决跨域资源不能互相访问的问题，引入了跨域资源共享(CORS),使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。

```js
router.get("/",async ctx=>{
    ctx.set('Access-Control-Allow-Origin','*')  //++
    ...
    
})
```

加上以上代码就可以实现跨域。

### 四、总结

同源策略会隔离不同源的DOM，页面数据和网络通信，进而实现**Web页面的安全性**。

不要安全性和便利性不能兼得，要绝对的安全就要牺牲掉便利性，因此我们要在二者之间做权衡，找到一个平衡点，这就是页面安全策略原型。它具有以下三个特点。

1、页面引入第三方资源的时候，会暴露很多问题，例如XSS攻击，因此在这种开发的基础上引入了CSP来限制。

2、XMLHttpRequest（Ajax核心对象）无法直接进行跨域请求，因此在这种严格策略的基础之上引入了**跨域资源共享策略**，可以安全地进行跨域操作。



# **2、跨站脚本攻击**

### 一、什么是XSS攻击

XSS全程是Cross Site Scripting,为了和"CSS"区分开来，故简称XSS。翻译过来就是"跨站脚本"。XSS攻击是指黑客往HTML文件中或DOM中注入恶意脚本，从而在用户浏览页面时，利用**注入的恶意脚本对用户实施攻击的一种手段**。

最开始的时候，这种攻击是通过跨域实现的，所以叫"跨域脚本"。但是发展到如今，往HTML文件注入恶意代码的方式越来越多，所以是否跨域注入脚本已经不是唯一的注入手段了，但是XSS这个名字却一直保留至今。

当页面被注入恶意脚本时，浏览器无法区别，所以注入的脚本也拥有了正常脚本的权限。如果页面被注入恶意脚本，脚本能够做哪些事情

- 可以**窃取Cookie信息**，恶意代码通过document.cookie获取Cookie信息，然后通过XMLHttpRequest加上Cors功能将数据发送给恶意服务器。恶意服务器拿到用户的Cookie信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
- 可以**监听用户行为**，恶意JavaScript可以使用"addEventListener"接口监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。
- 可以通过**修改DOM**，伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
- 还可以**在页面内生成浮窗广告**，这些广告会严重的影响用户体验。

如果让页面被插入恶意脚本，那么就相当于把我们页面的隐私数据和行为完全暴露给黑客了。

### 二、恶意脚本是怎么注入的

常见的恶意脚本注入有以下几种，存储型XSS攻击，反射型XSS攻击，基于DOM的XSS攻击。

![02.webp](/image/浏览器渲染/1627211783775-05a46cfb-07ff-496d-8e24-cd749fbdd3e0.webp)

通过上图，我们可以看出存储型XSS攻击大致需要经过如下步骤:

- 首先黑客利用站点漏洞将一段恶意JavaScript代码提交到网站的服务器
- 之后用户访问页面时，发送的请求中包含了恶意的脚本。
- 当用户浏览器页面的时候，恶意脚本就会将用户的Cookie信息等数据上传到恶意的服务器。

2015年喜马拉雅就被曝出了存储型XSS漏洞，起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段JavaScript，如下图

![02.webp](/image/浏览器渲染/1627212185048-acb093fa-3e13-4ae2-b95d-dfb2a725a217.webp)

> 黑客将恶意代码存储到漏洞服务器上

当黑客将专辑名称设置为一段JavaScript代码提交后，喜马拉雅服务器会保存该段JavaScript代码到数据库中，然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行(如下图)，这样就可以获取用户的Cookie等数据信息。

![01.webp](/image/浏览器渲染/1627212425108-dd3fcd21-9c1a-4260-abbf-e1df1ec5a08b.webp)

> 用户打开的页面中包含了恶意的脚本

当用户打开黑客设置的专辑页面时，服务器也会将这段恶意JS脚本返回给用户，因为这段恶意脚本就在用户的页面中执行了。

恶意脚本通过XMLHttpRequest将用户的Cookie数据，传到黑客的服务器。

黑客拿到了用户Cookie信息之后，就可以利用Cookie信息在其他机器上登录。并进行一些恶意的操作

以上就是存储型XSS攻击的一个典型案例。

#### 2、反射型XSS攻击

恶意脚本属于用户发送请求的一部分，随后服务器又把恶意脚本返回给用户。当恶意脚本在用户页面中被执行时，黑客就可以利用恶意脚本做一些操作。

下面我们结合一个简单的Node服务程序来看看深恶是反射型XSS，首先我们搭建一个Node服务

```json
//package.json
{
  "name": "server",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "dependencies": {
    "art-template": "^4.13.2",
    "koa": "^2.13.1",
    "koa-art-template": "^1.1.1",
    "koa-router": "^10.0.0"
  }
}
```

```js
//index.js
const koa = require("koa");
const router = require("koa-router")();
const app = new koa();
const render = require('koa-art-template');
const {
    resolve
} = require('path');
render(app, {
    root: resolve(__dirname, 'views'),
    extname: '.html'
});
router.get("/",async ctx=>{
    await ctx.render("index",{title:"Koa",xss:ctx.query.xss})
})
app.use(router.routes());
app.listen(8080)
```

```html
// views/index.html

<!DOCTYPE html>
<html>
<head>
  <title><%= title %></title>
</head>
<body>
  <h1><%= title %></h1>
  <p>Welcome to <%= title %></p>
  <div>
      <%- xss %>
  </div>
</body>
</html>
```

我们再本地演示，打开http://localhost:8080/?xss=2，这个衔接显示如下:

![01.png](/image/浏览器渲染/1627213662989-69929603-651d-467c-989e-37b5e3d69a3e.png)

但当打开

```
http://localhost:8080/?xss=<script>alert('你被xss攻击了')</script>
```

这段 URL 时，其结果如下图所示：

![02.png](/image/浏览器渲染/1627213773547-96a37b2a-836d-4b8a-b4b7-6f0668db663d.png)

页面被插入恶意脚本。

通过这个操作，我们会发现用户将一段含**有恶意代码的请求提交给Web服务器，Web服务器接收到请求时，又将恶意代码反射给了浏览器**，这就是反射型XSS攻击。在现实生活中，黑客经常会通过QQ群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。

另外需要注意的是，Web服务器不会存储反射型XSS攻击的恶意脚本，这是和存储型XSS攻击不同的地方。

#### 3、基于DOM的XSS攻击

基于DOM的XSS攻击是不会牵涉到页面Web服务器的。具体来说，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面，修改页面。这种劫持类型很多，有通过WiFi路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在**Web资源传输过程或者在用户使用页面的过程中**修改Web页面的数据。

### 三、如何阻止XSS攻击

存储型XSS攻击和反射型XSS攻击都需要经过Web服务器来处理，因此可以认为这两种类型的漏洞是服务端的安全漏洞。

而基于DOM的XSS攻击全部都是在浏览器端完成的，因此**基于DOM的XSS攻击是属于前端的安全漏洞。**

那么无论是何种类型的XSS攻击，它们都是要首先**在浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。**

所以要阻止XSS攻击，我们可以通过阻止**恶意脚本的注入**和**恶意消息的发送**来实现。

> 就和新冠一样，防止输入，控制输出。

#### 1、服务器对输入的脚本进行过滤和转码

不管是反射还是存储型XSS攻击，我们都可以在服务器将一些关键的字符进行转码

比如我们可以通过正则，将以下代码过滤掉

```js
code:<script>alert('你被xss攻击了')</script>
```

```js
router.get("/",async ctx=>{
    var reg  = /<script.*?>.*?<\/script>/ig;
    var result  = ctx.query.xss.replace(reg,"");
    console.log(result)
    await ctx.render("index",{title:"Koa",xss:result})
})
```

当用户再次请求该页面时，由于 &lt;script&gt; 标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。

除了过滤之外，服务器还可以对这些内容进行转码，还是上面的代码，经过转码之后，效果如下所示:

```js
code:&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;
```

经过转码之后的内容，即使返回页面，脚本也不会执行。

#### 2、充分利用[CSP](https://baike.baidu.com/item/CSP/13343685?fr=aladdin)

虽然在服务器执行过滤或转码可以阻止XSS攻击的发生，但是完全依靠服务器端依然是不够的，我们还需要CSP等策略充分地利用起来，以降低XSS攻击带来的风险和后果。

实时严格的CSP可以有效地防范XSS攻击，具体来讲CSP有如下几个功能:

- 限制加载**其他域下的资源文件**，这样即使黑客插入了一个JavaScript文件，这个JavaScript文件也是无法加载的。
- 禁止向第三方提交数据，这样用户数据也不会外泄；
- 禁止执行内联脚本和未授权的脚本;
- 提供了上报机制，这样可以帮助我们尽快发现有哪些XSS攻击，以便尽快修复问题。

利用好CSP能够有效降低XSS攻击的概率。

#### 3、使用HttpOnly属性

由于很多XSS攻击都是用来盗用Cookie的，因此可以通过使用HttpOnly属性来保护我们Cookie的安全

```js
ctx.cookies.set("name","lisi",{
        httpOnly:false  //true表示浏览器端不可读  false可读 默认是true
 })
```

当HttpOnly被设置为true的时候，无法通过脚本读取到cookie的数据。因此一些重要的数据我们建议设置HttpOnly标志。

### 四、总结

XSS攻击就是黑客往页面恶意注入脚本,然后将页面的一些重要数据上传到恶意服务器。常见的三种XSS攻击模式是:

1、存储型XSS攻击

2、反射型XSS攻击

3、基于DOM的XSS攻击

这三种方式共同的特点都是需要往页面中注入恶意脚本，然后再通过恶意脚本将用户数据上传都黑客的恶意服务上。而三者的不同点在于注入的方式不一样，有通过服务器漏洞注入，还有客户端直接注入的。



除了上面我们提及的三种防范策略外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作，而对于一些不受信任的输入，还可以限制其输入长度，这样就可以增大XSS攻击的难度。

# **3、CSRF攻击**

CSRF(Cross-site request forgery)跨站请求伪造；顾名思义，是伪造请求，冒充用户在站内的正常操作；

该攻击可以在受害者毫不知情的情况下，以受害者名义伪造请求，发送给受攻击的站点。从而在未授权的情况下执行在权限保护之下的操作，具有很大的危害性，具体来讲，CSRF攻击。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的。但是却完成了攻击者所期望的一个操作，比如以你的名义，发送邮件发送消息，盗用你的账号，添加系统管理员。

![01.jpg](/image/浏览器渲染/1627297171446-945534f8-7c01-4304-bc0a-6ff1c17c4315.jpeg)

![01.png](/image/浏览器渲染/1627222605273-269f9f18-d000-4242-b403-d656a5584dd8.png)

1、李四登录了Gmail邮箱，Gmail服务器返回一些登录状态给李四的浏览器。这些信息包括了Cookie,Session等，这样在李四的浏览器，Gmai**l处理登录状态了**。

2、黑客通过各种手段引诱李四去打开他的链接，比如hack.com,然后再在hack.com页面中，黑客编写好了一个邮箱过滤器，并通过Gmail提供的HTTP设置接口设置了新的邮件过滤功能，该过滤器会将李四的邮件都转发到黑客的邮箱中。

### 一、什么是CSRF攻击

跨站请求伪造，指黑客引用用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF攻击就是黑客利用了用户的登录状态，并通过第三方站点来做一些坏事。

用户登录微博账号，这时黑客给你一个美女图片的链接，你点击之后进入黑客的网站，他获取你的登录状态，利用你的账号传播一些乱七八糟的信息。

和XSS不同的是，CSRF攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。

你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

### 二、如何防止CSRF攻击

发起CSRF攻击的三个必要条件

1、目标站点一定要有CSRF**漏洞**

2、用户要登录过目标站点，并且在浏览器上**保持有该站点的登录状态。**

3、用户需要打开第三方站点，可以是黑客网站，也可以是一些论坛。

满足三个条件，黑客就可以进行CSRF攻击了，这里需要注意的是，与XSS不同，CSRF攻击不需要注入脚本，因此黑客无法通过CSRF攻击来获取用户页面数据；其最关键一点是要找到服务器的漏洞，所以说对于CSRF攻击我们主要的防护手段是提升服务器的安全性。

以下有几种途径可以让服务器避免遭受CSRF攻击

#### 1、充分利用好Cookie的sameSite属性

黑客会利用用户的登录状态来发起CSRF攻击,而Cookie正是浏览器和服务器之间维持登录状态的一个关键数据。因此要阻止CSRF攻击，首先要考虑的就是在Cookie上做文章。

通常CSRF攻击都是从第三方站发起的，要防止。最好能实现第三方站放松请求时进制Cookie的发送。

- 如果从第三站点发送请求，那么需要浏览器禁止发送某些关键的Cookie数据到服务器；
- 同一站点发送的请求，正常发送。

使用SameSite属性可以有效降低CSRF攻击的风险。

HTTP响应头中，通过set-cookie字段设置Cookie,可以带上SameSite选项，如下:

```js
set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none
```

SameSite 选项通常有 Strict、Lax 和 None 三个值。

- Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。
- Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
- 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

####  2、验证请求的来源站点

CSRF攻击大多来自于第三方的站点，因此服务器可以禁止俩字第三方站点的请求。那么如何判断请求是否来自于第三方站点呢?

可以使用HTTP请求的Referer和Origin属性。

**Referer是HTTP请求头中的一个字段，记录了该HTTP请求的来源地址**。比如我从百度首页跳转到新闻页，那么请求头中的Referer值是百度的URL,如下图:

![01.png](/image/浏览器渲染/1627294464697-bf5fa4cd-92db-4f78-aa13-192049cf6e0f.png)

但在服务器端验证请求头中Referer并不是太可靠，因此我们还可以使用Origin属性，在一些重要的场合，比如通过XMLHttpRequest，Fetch发起跨站请求或者通过Post方法发送请求时，都会带上Origin属性，如下图

![02.png](/image/浏览器渲染/1627295003160-23b33bcc-03aa-4d6b-93d2-47462e831cd5.png)

Origin属性只包含了域名信息，并没有包含具体的URL路径，这是Origin和Referer的一个主要区别。

因此服务器的策略是优先判断Origin,如果请求头中没有包含Origin属性，再根据实际情况判断是否使用Referer值。

#### 3、CSRF Token

除了使用以上两种方式来防止CSRF攻击之外，还可以采用CSRF Token来验证，这个流程比较好理解。大致分为两步

第一，在浏览器向服务器发送请求时，服务器生成一个CSRF Token。CSRF Token其实就是服务器生成的字符串，然后将字符串植入到返回的页面中

```html
<!DOCTYPE html>
<html>
<body>
    <form action="https://time.geekbang.org/sendcoin" method="POST">
      <input type="hidden" name="csrf-token" value="nc98P987bcpncYhoadjoiydc9ajDlcn">
      <input type="text" name="user">
      <input type="text" name="number">
      <input type="submit">
    </form>
</body>
</html>
```

第二步，在浏览器如果要发起转账的请求，那么需要带上页面中的CSRF Token，然后服务器会验证该Token是否合法。如果是从第三方站发出的请求，那么将无法获取到CSRF Token,所以即使发出了请求，服务器也会因为CSRF Token不正确而拒绝请求。

### 三、总结

1、发起CSRF攻击需要具备三个条件:目标站存在漏洞，用户要登录过目标站点，黑客需要通过第三方站点发起攻击。

2、根据这三个必须要条件，我们介绍了该如何防止CSRF攻击，具体来讲主要有三种方式:充分利用好Cookie的SameSite属性，验证请求的来源站点和使用CSRF Token。这三种方式需要合理搭配使用，这样才可以有效地防止CSRF攻击。

结合前面讲的，页面安全问题的主要原因就是浏览器为同源策略开的两个"后门"：一个是在页面中可以任意引用第三方资源，另外一个是通过CORS策略让XMLHttpRequest和Fetch去跨域请求资源。

为了解决这些问题，我们引入CSP来限制页面任意引入外部资源，引入HttpOnly机制来禁止XMLHttpRequest或者Fetch发送一些关键Cookie，引入SameSite和Origin来防止CSRF攻击。
